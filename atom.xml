<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-09-21T14:05:00.145Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/09/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AContext-Sensitive%20and%20Directional%20Concurrency%20%20Fuzzing%20for%20Data-Race%20Detection%E3%80%8B%EF%BC%88NDSS&#39;22%EF%BC%89/"/>
    <id>http://example.com/2024/09/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AContext-Sensitive%20and%20Directional%20Concurrency%20%20Fuzzing%20for%20Data-Race%20Detection%E3%80%8B%EF%BC%88NDSS&#39;22%EF%BC%89/</id>
    <published>2024-09-21T14:06:48.651Z</published>
    <updated>2024-09-21T14:05:00.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ruoyyy读论文-《Context-Sensitive-and-Directional-Concurrency-Fuzzing-for-Data-Race-Detection》（NDSS’22）"><a href="#Ruoyyy读论文-《Context-Sensitive-and-Directional-Concurrency-Fuzzing-for-Data-Race-Detection》（NDSS’22）" class="headerlink" title="[Ruoyyy读论文]《Context-Sensitive and Directional Concurrency  Fuzzing for Data-Race Detection》（NDSS’22）"></a>[Ruoyyy读论文]《Context-Sensitive and Directional Concurrency  Fuzzing for Data-Race Detection》（NDSS’22）</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p><strong>前人的限制：</strong>1、没有考虑线程交错的执行上下文，可能会错过特定条件运行时的一些数据竞争；2、随机执行线程交错，这是没有目的的，会错过一些不常见的线程交错；</p><p><strong>本文贡献：</strong>CONZZER，一种上下文敏感的定向并发模糊测试方法，两项创新技术：1、新的并发覆盖率指标，即<strong>并发调用对</strong>；2、<strong>邻接指导的突变</strong>，以生成新的可能的线程交错，其中包含已经覆盖的线程交错，然后使用 <strong>breakpointcontrol</strong> 方法尝试在运行时实际覆盖它们。</p><p><strong>实验：</strong>8个内核层程序，9个用户层程序，共发现95个data condition，75个有害，44个得到确认。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>背景：数据争用</strong>是一类常见的并发问题。当两个并发执行的线程访问一个共享变量，并且其中至少一个线程在没有适当的同步操作的情况下写入该变量时，就会发生这种情况。如：CVE-2020-1667、CVE-2020-9990和 CVE-202011173。</p><p><strong>现有方法：</strong>静态分析（纯粹弱智）、lockset分析、happens-before relation、采样，后三者需要大量的测试用例来涵盖运行时并发执行的代码和不同的线程交错。<strong>模糊测试</strong>，Syzkaller&#x2F;AFL+TSAN&#x2F;KSCAN，但传统的代码覆盖率作为反馈是落后的。现有的一些新的工作，如Razzer、Muzz、ConFuzz等等，虽然提出了一些比较新的指导策略，但有摘要中提到的两点限制。</p><p><strong>创新点：</strong></p><ul><li>新的并发覆盖率指标，称为<strong>并发调用对</strong>，用于描述线程与运行时调用上下文的交错。将线程交错与其运行时调用上下文描述为模糊测试反馈。</li><li>通过使用邻接导向的突变和<strong>breakpointcontrol</strong>方法，这种方法可以定向地探索尽可能多的线程交错。</li><li>动态lockset分析＋Conzzer实现了新的Race Checker，准确率大于TSan。</li></ul><h2 id="背景与动机"><a href="#背景与动机" class="headerlink" title="背景与动机"></a>背景与动机</h2><h3 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h3><p>简而言之，data race是危险的，然而传统的解决方法会产生大量的开销，如加锁等等，所以一般只会在必要的时候采用。这对于开发人员来说，是一件很困难的事。</p><p>来看一个简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux/fs/jfs/jfs_txnmgr.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">txEnd</span><span class="params">(...)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">log</span> = JFS_SBI(tblk→sb)→<span class="built_in">log</span>;<span class="comment">//read</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(--<span class="built_in">log</span>→active == <span class="number">0</span>)<span class="comment">//log is null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//linux/fs/jfs/jfs_logmgr.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ImLogClose</span><span class="params">(...)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">jfs_sb_info</span> *<span class="title">sbi</span> =</span> JFS_SBI*(sb);</span><br><span class="line">    ...</span><br><span class="line">    sbi→<span class="built_in">log</span> == <span class="literal">NULL</span>;<span class="comment">//write</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果发生了数据竞争，则对sbi→log的读后写造成了空指针解引用。这是Linux 2.6.12的源码，写于2005年，直到被Conzzer发现。</p><p>现在我们观察，事实上，上下两种调用栈会有不一样的结果。</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240920192541770.png" alt="image-20240920192541770"></p><p>$CallPair_1$这种线程交错在实际的使用中是很少出现的。 所以说在实际的漏洞挖掘中，这样的漏洞是很难发现的。</p><h3 id="SOTA存在的问题"><a href="#SOTA存在的问题" class="headerlink" title="SOTA存在的问题"></a>SOTA存在的问题</h3><ul><li>传统的顺序代码覆盖率作为反馈的AFL&#x2F;Syzkaller是很落后的，于是后人改造传统的代码覆盖率（Razzer、Muzz、Confuzz）或提出了<strong>并发覆盖率</strong>（KRACE），前者无法真正的描述线程交错的情况，后者虽然提出了并发覆盖率的概念，但是没有考虑到上下文，$CallPair_1$和$CallPair_2$就被视作了一种情况，这是我们不想看到的。</li><li>KRACE还提出了在内存访问点注入随机延迟，Muzz提出随机调整线程优先级等等，但这样总体来说仍然是低效的，还是会重复常见的线程交错，说到最后还是没有考虑上下文。由于缺乏具体的运行时上下文和缺少许多不频繁的线程交错，现有的并发模糊测试方法在发现难以找到的数据竞争方面仍然受到限制。</li></ul><h2 id="上下文相关的定向模糊测试"><a href="#上下文相关的定向模糊测试" class="headerlink" title="上下文相关的定向模糊测试"></a>上下文相关的定向模糊测试</h2><h3 id="上下文敏感的并发调用对"><a href="#上下文敏感的并发调用对" class="headerlink" title="上下文敏感的并发调用对"></a>上下文敏感的并发调用对</h3><p>为了确保上下文敏感性，此方法使用新的并发覆盖率指标 <em><strong>Concurrent Call Pair</strong></em>，将线程交错与其运行时调用上下文描述为模糊反馈。</p><p>考虑这样一种描述：<br>$$<br>ConCallP air &#x3D; [CallCtxa, CallCtxb]<br>$$<br>作者使用函数的运行时调用堆栈 （$CallCt_x$） 来描述函数的调用上下文，它包含调用堆栈中每个函数调用 （$CallInfo$） 的信息（从调用方到被调用方），包括此函数调用的位置 （$CallLoc$） 和被调用函数的位置 （$FuncLoc$）。<br>$$<br>CallCtx&#x3D;{CallInfo_1, CallInfo_2, …, CallInfo_n}<br>$$</p><p>$$<br>CallInfo &#x3D; [CallLoc, FuncLoc]<br>$$</p><p>根据上述描述，可以将每个并发调用对的信息作为 key 进行哈希存储，并将每个调用对覆盖的次数表示为哈希值。通过这种方式，类似于存储在 AFL中的代码覆盖率，并发调用对可以作为键值对存储在哈希表中：</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240920200633496.png" alt="image-20240920200633496"></p><p>当程序开始运行时，作者去<strong>动态</strong>识别并收集并发调用对，假设两个函数在N个不同的上下文中被并发调用，则会产生N个并发调用对。在这种情况下，$CallPair_1$和$CallPair_2$就会被区分开。</p><h3 id="定向线程交错"><a href="#定向线程交错" class="headerlink" title="定向线程交错"></a>定向线程交错</h3><p><strong>如何智能地去定向发现一些罕见的线程交错呢？</strong>考虑这样一种情况，$Func_A$和$Func_B$并发执行，我们可以推断$Func_A$的调用方和被调用方会和$Func_B$并发执行。然后我们就可以确定性地影响线程调度来检查可能的线程交错是否真实。</p><p>基于这种思想，作者提出了：1、<strong>邻接导向的突变</strong>以产生新的可能的线程交错，其中包含已经覆盖的线程交错；2、<strong>breakpointcontrol</strong> 方法，用于尝试在运行时实际覆盖这些新的可能的线程交错。</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240920205356657.png" alt="image-20240920205356657"></p><p>总结来说，Conzzer的流程是:</p><ul><li>编译时，在每一个函数的入口处打一个断点并插入一个时间延迟；</li><li>在不触发断点的情况下，执行一遍程序，并收集覆盖的并发调用对和线程执行信息；</li><li>程序执行后，将这些覆盖的并发调用对添加到一个全局集合对集中，该集合对记录所有不同的覆盖并发调用对；</li><li>它使用线程执行信息对这些覆盖的并发调用对执行邻接导向的突变，以生成新的可能的并发调用对；</li><li>再执行被测试的程序，使用 <strong>breakpointcontrol</strong> 方法确定性地和自适应地覆盖可能的并发调用对，并收集覆盖的并发调用对和线程执行信息；</li><li>程序执行后，它通过与对集进行比较，从这些覆盖的并发调用对中识别新的覆盖的并发调用对，并再次像第四步一样使用线程执行信息迭代改变这些新的并发调用对，从而构建一个模糊测试循环。</li></ul><h4 id="什么是邻接导向突变"><a href="#什么是邻接导向突变" class="headerlink" title="什么是邻接导向突变"></a>什么是邻接导向突变</h4><p>还是考虑上面说到的情况：$Func_A$和$Func_B$并发执行，我们可以推断$Func_A$的调用方和被调用方会和$Func_B$并发执行，类似的，$Func_B$的调用方和被调用方会和$Func_A$并发执行，$Func_A$的调用方和被调用方会和$Func_B$的调用方和被调用方并发执行……。所以，作者提出了一个推理，根据已经涵盖的并发调用对，可以在有希望的方向上识别新的可能的线程交错。（听起来像是弱智）</p><p><strong>推理：</strong>如果 $Func_A$ 和 $Func_B$ 与调用上下文 $CallCtx_a$ 和 $CallCtx_b$ 同时执行，并且 $Func_B$ 和 $Func_C$ 与调用上下文 $CallCtx_b$ 和 $CallCtx_c$ 相邻执行，则 $Func_A$ 和 $Func_C$ 可以与调用上下文 $CallCtx_a$ 和 $CallCtx_c$ 同时执行。</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240920210101180.png" alt="image-20240920210101180"></p><p><strong>输入：</strong>已经覆盖的并发调用对；<strong>输出：</strong>新的可能的并发调用对</p><p>对于每个覆盖的并发调用对，更改将获得其两个相应的调用上下文 $CallCtx_1$ 和$CallCtx_2$ （第 2-3 行）。然后，将 $CallCtx<br>_1$ 的每个相邻调用上下文 $AdjCallCtx_1$ 与 $CallCtx_2$ 组合，生成一个新的可能的并发调用对 $ConCallPair$（第 4-5 行）。如果 $ConCallPair$ 不与现有的并发呼叫对重复，它将被添加到可能的对集中（第 6-7 行）。同样，$CallCtx_2$ 也以这种方式处理（第 8-11 行），以生成新的可能的并发调用对。注意，如果 $AdjCallCtx$ 对应的函数可以在这些调用上下文中相邻执行，则认为 $AdjCallCt_x$ 是 $CallCt_x$ 的相邻调用上下文。</p><p>举个例子：给一个已经覆盖的并发调用对$[CallCtx_a, CallCtx_b]$，选择并发执行的函数$Func_A$和$Func_B$，并标识有关其线程 $Thread_1$和 $Thread_2$的运行时信息。然后，该变更检查有关$Thread_1$的信息，并识别与 $Func_A$ 相邻执行的两个函数$Func_{A-1}$和 $Func_{A+1}$。该突变推断$Func_{A-1}$和 $Func_{A+1}$在特定调用上下文中执行时也可能与$Func_B$并发。基于这个推论，从收集到的有关 $Thread_1$ 的信息中，突变确定了$Func_{A-1}$和 $Func_{A+1}$的相应调用堆栈，即 $CallCtx_{a−1}$ 和 $CallCtx_{a+1}$，然后将它们中的每一个与 $CallCtx_b$ 组合在一起，生成两个新的可能的并发调用对$[CallCtx_{a-1},  CallCtx_b]$ 和 $[CallCtx_{a+1}， CallCtx_{b}]$。同样，该变更还处理$ Func_B$ 和有关 $Thread_2$的运行时信息，以生成另外两个新的可能的并发调用对 $[CallCtx_a， CallCtx_{b−1}] $和 $[CallCtx_a， CallCtx_{b+1}]$。总共从给定对中生成了四个新的可能的并发调用对，其中两个在与现有覆盖的调用对进行比较时被丢弃。</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240920211803030.png" alt="image-20240920211803030"></p><h4 id="什么是breakpointcontrol"><a href="#什么是breakpointcontrol" class="headerlink" title="什么是breakpointcontrol"></a>什么是breakpointcontrol</h4><p>由于程序的执行过程中，并发是不确定的，所以很难整整覆盖到所有可能的并发调用对。这个<strong>breakpointcontrol</strong>有两种模式：1、对于每一个并发调用对，执行确定性断点控制以尝试覆盖它；2、对于整个可能的并发调用对集，执行自适应断点控制。</p><p><strong>第一种模式：</strong>具体实现上，假设有一个并发调用对$[CallCtx_p,  CallCtx_q]$，则存在两个函数$Func_P$和$Func_Q$，执行$Func_P$时，若执行的过程是符合$CallCtx_p$的，则会触发断点，线程延迟并等待$Func_Q$执行。在等待的过程中，<strong>若$Func_Q$执行并且执行的上下文也符合$CallCtx_q$的</strong>，那么意味着这个并发调用对被覆盖到了，那么将会禁用这个断点，反过来，若在等待结束后$Func_Q$也不会执行，那么意味着这种并发调用对永不会执行，那么也会禁用这个断点。</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240920215058066.png" alt="image-20240920215058066"></p><p><strong>第二种模式：</strong>若每次运行都只处理一个并发调用对，则反复执行程序的次数过多，若一次群不处理每一个可能的并发调用对，那么程序开销过大，也有可能会令程序崩溃。所以在每次运行中正确选择可能的并发调用对非常重要。为了解决这个问题，就有了第二种模式，这种模式类似于TCP拥塞控制。</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240921162555613.png" alt="image-20240921162555613"></p><p>如算法2，输入可能的并发调用对集，将选择数初始化为1，在循环中随机从可能的并发调用对中随机选择<em>select_num</em>个并发调用对，并将它们存在<em>try_pair_set</em>集合中，然后程序执行<strong>breakpointcontrol</strong>方法，然后将覆盖的并发调用对存储到<em>covered_pair_set</em>中，取<em>try_pair_set</em>和<em>covered_pair_set</em>的交集，存入<em>common_pair_set</em>中。如果 <em>common_pair_set</em> 不为空，该方法将从可能的并发调用对集中删除 <em>common_pair_set</em> 中存在的 <em>call_pairs</em>（第 8 行），表示不再需要处理这些 <em>call_pairs</em>。如果 <em>common_pair_set</em> 为空，则表示实际上没有覆盖任何选定的调用对，因此该方法将 <em>select_num</em> 加倍，以提供在下一次运行中覆盖一个调用对的更多机会（第 10 行）。最后，该方法检查循环条件并准备进入下一次迭代。</p><h3 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h3><p>在实际的设计上，作者曾经考虑过采用<strong>并发指令对</strong>或者<strong>并发基本块对</strong>，但这样的做法开销实在太大了，会使模糊测试的效率大大降低，并发指令对在考虑上下文时会有过度敏感问题。为了验证这一点，作者实现了一个名为 inst-fuzzer 的替代工具，它使用并发指令对作为随机线程交错探索的反馈，而不考虑指令对的运行时上下文，并与之进行实验比较。作者还考虑了上文的<strong>第二种模式</strong>，线性增加<em>select_num</em>（*select_num++*），或者说一次打开所有的断点等等，都会使模糊测试的效率下降。</p><h2 id="Conzzer的具体实现"><a href="#Conzzer的具体实现" class="headerlink" title="Conzzer的具体实现"></a>Conzzer的具体实现</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240921171437127.png" alt="image-20240921171437127"></p><ul><li><p>代码分析器：它编译和检测程序代码，最后生成一个经过测试的可执行程序。</p></li><li><p>运行时分析器：它用<strong>生成的程序输入</strong>执行被测试的程序，记录程序的运行时信息，并根据生成的可能的并发调用对进行断点控制。</p></li><li><p>调用对生成器：它根据线程执行信息改变覆盖的并发调用对，以生成新的可能的并发调用对。</p></li><li><p>输入生成器：它利用输入驱动的模糊测试过程，根据代码覆盖率来改变和生成新的输入。</p></li><li><p><strong>竞争检查器：</strong>它分析我们的并发模糊测试方法所涵盖的线程交错的运行时信息，以检测数据争用。（这是一个重点）</p></li></ul><p>作者首先阐述了第三方竞争检查器TSan会产生大量的误报，因为存在消息队列和条件变量。所以作者开发了新的竞争检查器，简单来说就是两步：</p><ol><li>动态锁集分析：<strong>首先解释什么是锁集（lockset）分析？简单来说，对于每一个线程$t$，都维护一个当前获取的锁集$locks_held(t)$，每一个共享变量$t$，初始化都会获取程序执行过程中的所有锁集$C(v)$，当前线程对这个变量进行读写时，就会$C(v) &#x3D; C(v)∩locks_held(t)$，若$C(v) &#x3D; {}$，就会有警告。</strong>在本篇文章中，一旦检测到两个函数在运行时并发执行，它对这两个函数中的内存访问动态执行锁集分析，以检测可能的数据竞争。对于每种可能的数据争用，作者的检查器会记录其<strong>racy</strong>指令和由本文的并发模糊方法识别的相关并发调用对。</li><li>对于每个报告的可能数据争用，检查器会在其<strong>racy</strong>指令（可能发生race的指令）处注入断点，然后再次执行程序。在程序执行期间，检查器维护每个线程的调用上下文，并动态控制断点，以尝试同时执行访问<strong>同一变量</strong>的<strong>racy</strong>指令（记录下来的并发调用对）。如果尝试成功，则此可能的数据争用将被标识为真实的。</li></ol><p><strong>优点：</strong>没有假阳性，因为是在真实执行中触发的；</p><p><strong>缺点：</strong>会有假阴性，也就是不全；作者建议，多次执行以消除假阴性；</p><h4 id="代码插桩"><a href="#代码插桩" class="headerlink" title="代码插桩"></a>代码插桩</h4><p>需要在LLVM字节码的三个位置进行插桩：</p><ul><li>调用上锁&#x2F;释放锁的函数，检测它们来维护正在运行线程的内存访问锁集</li><li>每个函数的定义和调用，对每个函数的进入和退出以及每个函数调用进行检测，以收集并发调用对和调用上下文信息。</li><li>对可能的共享变量的内存访问，这里是静态分析出来的，使用的是（Efficient and Precise Datarace Detection for Multithreaded Object-Oriented Programs[PLDI’02]），一款比较老的工具。</li></ul><h4 id="Fuzzing的流程"><a href="#Fuzzing的流程" class="headerlink" title="Fuzzing的流程"></a>Fuzzing的流程</h4><p>这里不做过多的赘述，流程就是：插桩→执行→动态锁集分析→race检查，这里有一点需要注意，Conzzer使用的加锁&#x2F;释放锁函数是POSIX 线程库和 Linux 官方文档中描述的常用锁获取&#x2F;释放函数（如 pthread_mutex_lock），对于部分程序自定义的一些加锁&#x2F;释放函数，就会有一些误报了<strong>（可能是改进点）</strong>。</p><p>还有一部分是关于与 Input-Driven Fuzzing 的兼容性，这里不多说了，有兴趣可以看一看。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>实验对象：</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240921192212021.png" alt="image-20240921192212021"></p><p>实验配置：5轮测试，每一轮24hours；对于 8 个用户级应用程序，作者运行他们的官方多线程测试套件;对于 4 个内核级文件系统，作者运行一个著名的文件系统基准测试 iozone v3.429；</p><p>实验结果：</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240921210423316.png" alt="image-20240921210423316"></p><p> “Cover”、“Gen” 和 “Real” 分别表示覆盖的并发调用对的数量、由邻接导向的变异生成的可能的并发调用对以及运行时实际覆盖的可能并发调用对。“可能”、“最终”和“有害”列分别表示自定义Race检查器报告的，Conzzer报告的以及手测的数据race数量。</p><p>观察得出以下结论：</p><ul><li>由邻接导向的变异生成的可能的并发调用对是有效的；</li><li>可以有效发现数据竞争（共发现95个数据竞争，手动识别出了75个有害的，其中44个被确认，具体在附录里，感兴趣的可以自己找原文看看。）；<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240921211557351.png" alt="image-20240921211557351"></li><li>良性的数据竞争允许发生，因为对核心业务不造成影响，而且加锁会降低程序的运行效率；</li></ul><h3 id="数据竞争的特征"><a href="#数据竞争的特征" class="headerlink" title="数据竞争的特征"></a>数据竞争的特征</h3><ol><li>对存储在堆内存中的数据结构字段的访问时发生了 77 次数据竞争，而对全局变量的访问时只发生了 18 次数据竞争。事实上，<strong>与全局变量相比，识别存储在堆内存中的两个变量是否相同更加困难</strong>，因为它们的别名关系可能从它们的名称中隐含出来。图 1 中所示的有害数据竞争就是这样一个例子，变量 $JFS_SBI(tblk→sb)→log $和 $sbi→log$ 的别名关系从它们的名称中隐含出来。</li><li>53 个数据争用涉及其调用堆栈中的函数指针调用。如果没有确切的运行时信息，<strong>通常很难正确识别函数指针调用的目标。</strong></li><li>5个数据竞争发生在程序初始化或者结束时，有些进程会和主进程同时执行，这是很值得重视的，<strong>这里的数据竞争是危险的！</strong></li></ol><h3 id="数据竞争的危害性"><a href="#数据竞争的危害性" class="headerlink" title="数据竞争的危害性"></a>数据竞争的危害性</h3><h4 id="可能会DOS"><a href="#可能会DOS" class="headerlink" title="可能会DOS"></a>可能会DOS</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240921213953125.png" alt="image-20240921213953125"></p><p>在函数<code>btrfs_tree_unlock()</code> 中，变量<code>eb→blocking_writters</code>在第 313 行递减。在函数 <code>btrfs_tree_read_lock</code> 中，在第 135 行和第 152 行读取变量 <code>eb→blocking_writters</code>，以分别在意外终止 （BUG_ON） 和等待操作 （wait_event） 的情况下与零进行比较。如果 <code>eb→blocking_writters</code> 在 <code>btrfs_tree_unlock</code>行的第 313 行递减为零，然后在<code>btrfs_tree_read_lock</code>的第 135 行读它，则可以触发 BUG_ON 来终止文件系统执行。如果 <code>eb→blocking_writters</code>变为零，并且此变量总是在<code>btrfs_tree_unlock</code>的第 313 行递减，然后在<code>btrfs_tree_read_lock</code>的第 151 行读取，则<code>wait_event</code>始终会导致相关的文件系统线程休眠。</p><h4 id="数据破坏或篡改"><a href="#数据破坏或篡改" class="headerlink" title="数据破坏或篡改"></a>数据破坏或篡改</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240921214007475.png" alt="image-20240921214007475"></p><p>一些数据竞争可以操纵下载文件的内容（对于 <em>aget</em> 和 <em>axel</em>），攻击者可以利用这些文件持续注入恶意代码；一些数据竞争会干扰媒体处理器（适用于 x264 和 ffmpeg）的编码过程，攻击者可以利用这些过程来操纵向用户显示的视频内容，从而导致点击劫持和“所见即所得”等攻击。当两个函数在两个线程中同时执行时，函数 <code>conn_setup</code> 中的变量<code>conn→lastbyte</code>和函数<code>reactivate_connection</code>中的变量<code>axel→conn[idx].lastbyte</code>可以共享。在这种情况下，当同时执行对 <code>conn→lastbyte</code>的读取和对<code>axel→conn[idx].lastbyte</code>的写入时，将发生数据争用。触发此数据竞争后，<code>conn_setup</code> 中的<code>conn→http→lastbyte</code>可能会从<code>conn→lastbyte</code>获取不正确的值，这可能会损坏下载的文件。通过利用这个 race，攻击者可以控制 <code>conn→lastbyte</code> 的值来修改下载文件的内容并注入恶意代码。</p><h4 id="改变控制流"><a href="#改变控制流" class="headerlink" title="改变控制流"></a>改变控制流</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240921215343096.png" alt="image-20240921215343096"></p><p>在函数 <code>analyse_update_cache</code> 和 <code>x264_frame_cond_broadcast</code> 中，包含字段 <code>i_lines_completed</code> 的两个变量在测试中是相同的。触发数据竞争后，可以为 <code>analyse_update_cache</code> 中的变量 <code>complete</code> 分配不正确的值，并且可以满足 <code>analyse_update_cache</code> 中第 3861 行的条件，从而导致 x264 报告导致程序故障的内部错误。</p><h3 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h3><p>这部分不是重点，我略了。</p><h3 id="与其他模糊测试器的对比"><a href="#与其他模糊测试器的对比" class="headerlink" title="与其他模糊测试器的对比"></a>与其他模糊测试器的对比</h3><p>和AFL++, Syzkaller and Instruction-Level Fuzzer对比：</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240921215627708.png" alt="image-20240921215627708"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240921215639899.png" alt="image-20240921215639899"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240921215744367.png" alt="image-20240921215744367"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240921215754869.png" alt="image-20240921215754869"></p><p>这部分也不算重点，总之就是对比下，无论是并发调用对覆盖率，还是数据竞争的发现数量，还是时间效率，还是精准率，Conzzer都是表现最好的！</p><h3 id="其他模糊测试工具的不足"><a href="#其他模糊测试工具的不足" class="headerlink" title="其他模糊测试工具的不足"></a>其他模糊测试工具的不足</h3><p><strong>Razzer：</strong>首先使用静态分析来识别可能的racy指令，然后在可能的racy指令处注入代码断点，以尝试在运行时触发相关的竞争错误。CONZZER 与 Razzer 有三个显著区别：1） Razzer 的静态分析不够准确，无法识别涉及复杂情况的真实不规则指令（例如别名关系和函数指针调用），导致其动态分析错过了许多真实的数据竞争。相比之下，CONZZER 使用上下文敏感的定向并发模糊方法来有效地探索不频繁的线程交错，帮助发现难以发现的数据争用。 2） Razzer 仅查找由竞争条件引起的内存错误和警告，并且不使用任何竞争检查器。但是，许多有害的数据竞争永远不会导致内存错误。 3） Razzer 只能使用修改后的虚拟机测试操作系统内核。相比之下，CONZZER 可以在物理机上同时测试内核级程序和用户级应用程序，部署更方便。 </p><p><strong>KRACE ：</strong>。它利用新的并发覆盖率指标 <em>alias instruction pair</em> 来描述线程交错。此指标与 instfuzzer使用的并发调用对相同。它还注入随机延迟以覆盖不同的线程交错。为了涵盖更多的并发代码，它使用进化算法来改变并生成多线程 syscall 序列作为并发模糊测试的输入。将 CONZZER 与 KRACE 进行了比较：1） KRACE 使用的<em>alias instruction pair</em> 是一个上下文无关的指标，即它只描述两条并发执行的指令的位置，而不考虑它们的执行上下文。相比之下，CONZZER 使用一个新的上下文相关指标，即并发调用对，它同时考虑两个并发执行的函数的位置和调用上下文。因此，CONZZER 在查找仅在特定运行时上下文中发生的数据争用方面更加有效。 2） KRACE 使用的随机延迟注入在线程交错探索中效率低下，即它经常重复已经覆盖的线程交错，并错过许多不常见的线程交错。相比之下，CONZZER 使用定向模糊方法来推断和覆盖新的可能的线程交错，从而可以更有效地覆盖不频繁的线程交错。</p><p><strong>MUZZ ：</strong>它使用线程感知 instrumentation 来收集线程交错引起的代码覆盖率变化，以改进并发模糊测试的种子选择。此外，它还会在运行时随机调整被测程序的线程优先级，以尝试在模糊测试期间覆盖不同的线程交错。CONZZER 与 MUZZ 有两个显著的区别：1） 虽然通过线程交错引起的变化进行了增强，但代码覆盖率仍然主要描述顺序执行情况，因此在描述并发执行情况和指导并发模糊测试方面受到限制。为了彻底替换代码覆盖率，CONZZER 利用了一个新的并发覆盖率指标，即<strong>并发调用对</strong>，它可以有效地描述具有不同调用上下文的线程交错。 2） 与随机延迟注入类似，随机调整线程优先级在覆盖不频繁的线程交错方面也是无效的。为了解决这个问题，CONZZER 使用定向模糊测试方法来执行更有效、更高效的线程交错探索。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ruoyyy读论文-《Context-Sensitive-and-Directional-Concurrency-Fuzzing-for-Data-Race-Detection》（NDSS’22）&quot;&gt;&lt;a href=&quot;#Ruoyyy读论文-《Context-Sen</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/09/20/hello-world/"/>
    <id>http://example.com/2024/09/20/hello-world/</id>
    <published>2024-09-20T06:45:23.619Z</published>
    <updated>2024-09-20T06:45:23.620Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
